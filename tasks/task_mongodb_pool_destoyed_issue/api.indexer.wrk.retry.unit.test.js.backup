'use strict'

const { test } = require('brittle')
const sinon = require('sinon')

test('_isMongoTransientError detects pool destruction errors', (t) => {
  const wrk = {
    _isMongoTransientError (err) {
      const message = err.message || ''
      return (
        message.includes('Pool was force destroyed') ||
                message.includes('connection') ||
                message.includes('ECONNREFUSED') ||
                message.includes('ECONNRESET') ||
                message.includes('ETIMEDOUT') ||
                message.includes('topology was destroyed') ||
                message.includes('server selection timed out')
      )
    }
  }

  t.ok(wrk._isMongoTransientError(new Error('Pool was force destroyed')))
  t.ok(wrk._isMongoTransientError(new Error('connection timeout')))
  t.ok(wrk._isMongoTransientError(new Error('ECONNREFUSED')))
  t.ok(wrk._isMongoTransientError(new Error('topology was destroyed')))
  t.ok(wrk._isMongoTransientError(new Error('server selection timed out')))
  t.absent(wrk._isMongoTransientError(new Error('invalid query')))
  t.absent(wrk._isMongoTransientError(new Error('ERR_ADDRESS_FILTER_INVALID')))
})

test('_withMongoRetry succeeds on first attempt', async (t) => {
  t.plan(2)

  const mockLogger = {
    warn: sinon.spy(),
    error: sinon.spy()
  }

  const wrk = {
    logger: mockLogger,
    _isMongoTransientError (err) {
      const message = err.message || ''
      return message.includes('Pool was force destroyed')
    },
    async _withMongoRetry (fn, maxRetries = 2) {
      let lastError

      for (let attempt = 0; attempt <= maxRetries; attempt++) {
        try {
          return await fn()
        } catch (err) {
          lastError = err

          if (this._isMongoTransientError(err) && attempt < maxRetries) {
            const backoffMs = 200 * Math.pow(2, attempt)
            this.logger.warn(
              { err: err.message, attempt: attempt + 1, maxRetries, backoffMs },
              'MongoDB query retry due to transient error'
            )
            await new Promise(resolve => setTimeout(resolve, backoffMs))
            continue
          }

          if (attempt === maxRetries && this._isMongoTransientError(err)) {
            this.logger.error(
              { err: err.message, attempts: maxRetries + 1 },
              'MongoDB query failed after all retries'
            )
          }
          throw err
        }
      }

      throw lastError
    }
  }

  const result = await wrk._withMongoRetry(() => Promise.resolve({ data: 'success' }))

  t.alike(result, { data: 'success' })
  t.is(mockLogger.warn.callCount, 0, 'should not log warnings on success')
})

test('_withMongoRetry retries on transient error and succeeds', async (t) => {
  t.plan(4)

  const mockLogger = {
    warn: sinon.spy(),
    error: sinon.spy()
  }

  const wrk = {
    logger: mockLogger,
    _isMongoTransientError (err) {
      const message = err.message || ''
      return message.includes('Pool was force destroyed')
    },
    async _withMongoRetry (fn, maxRetries = 2) {
      let lastError

      for (let attempt = 0; attempt <= maxRetries; attempt++) {
        try {
          return await fn()
        } catch (err) {
          lastError = err

          if (this._isMongoTransientError(err) && attempt < maxRetries) {
            const backoffMs = 200 * Math.pow(2, attempt)
            this.logger.warn(
              { err: err.message, attempt: attempt + 1, maxRetries, backoffMs },
              'MongoDB query retry due to transient error'
            )
            await new Promise(resolve => setTimeout(resolve, backoffMs))
            continue
          }

          if (attempt === maxRetries && this._isMongoTransientError(err)) {
            this.logger.error(
              { err: err.message, attempts: maxRetries + 1 },
              'MongoDB query failed after all retries'
            )
          }
          throw err
        }
      }

      throw lastError
    }
  }

  let callCount = 0
  const mockFn = async () => {
    callCount++
    if (callCount === 1) {
      throw new Error('Pool was force destroyed')
    }
    return { data: 'success after retry' }
  }

  const start = Date.now()
  const result = await wrk._withMongoRetry(mockFn)
  const elapsed = Date.now() - start

  t.alike(result, { data: 'success after retry' })
  t.is(callCount, 2, 'should have called function twice (1 fail + 1 success)')
  t.is(mockLogger.warn.callCount, 1, 'should log one retry warning')
  t.ok(elapsed >= 200, 'should have backoff delay of at least 200ms')
})

test('_withMongoRetry fails after max retries exhausted', async (t) => {
  t.plan(4)

  const mockLogger = {
    warn: sinon.spy(),
    error: sinon.spy()
  }

  const wrk = {
    logger: mockLogger,
    _isMongoTransientError (err) {
      const message = err.message || ''
      return message.includes('Pool was force destroyed')
    },
    async _withMongoRetry (fn, maxRetries = 2) {
      let lastError

      for (let attempt = 0; attempt <= maxRetries; attempt++) {
        try {
          return await fn()
        } catch (err) {
          lastError = err

          if (this._isMongoTransientError(err) && attempt < maxRetries) {
            const backoffMs = 200 * Math.pow(2, attempt)
            this.logger.warn(
              { err: err.message, attempt: attempt + 1, maxRetries, backoffMs },
              'MongoDB query retry due to transient error'
            )
            await new Promise(resolve => setTimeout(resolve, backoffMs))
            continue
          }

          if (attempt === maxRetries && this._isMongoTransientError(err)) {
            this.logger.error(
              { err: err.message, attempts: maxRetries + 1 },
              'MongoDB query failed after all retries'
            )
          }
          throw err
        }
      }

      throw lastError
    }
  }

  let callCount = 0
  const mockFn = async () => {
    callCount++
    throw new Error('Pool was force destroyed')
  }

  await t.exception(
    () => wrk._withMongoRetry(mockFn),
    /Pool was force destroyed/
  )

  t.is(callCount, 3, 'should have called function 3 times (initial + 2 retries)')
  t.is(mockLogger.warn.callCount, 2, 'should log 2 retry warnings')
  t.is(mockLogger.error.callCount, 1, 'should log final error after retries exhausted')
})

test('_withMongoRetry does not retry non-transient errors', async (t) => {
  t.plan(3)

  const mockLogger = {
    warn: sinon.spy(),
    error: sinon.spy()
  }

  const wrk = {
    logger: mockLogger,
    _isMongoTransientError (err) {
      const message = err.message || ''
      return message.includes('Pool was force destroyed')
    },
    async _withMongoRetry (fn, maxRetries = 2) {
      let lastError

      for (let attempt = 0; attempt <= maxRetries; attempt++) {
        try {
          return await fn()
        } catch (err) {
          lastError = err

          if (this._isMongoTransientError(err) && attempt < maxRetries) {
            const backoffMs = 200 * Math.pow(2, attempt)
            this.logger.warn(
              { err: err.message, attempt: attempt + 1, maxRetries, backoffMs },
              'MongoDB query retry due to transient error'
            )
            await new Promise(resolve => setTimeout(resolve, backoffMs))
            continue
          }

          if (attempt === maxRetries && this._isMongoTransientError(err)) {
            this.logger.error(
              { err: err.message, attempts: maxRetries + 1 },
              'MongoDB query failed after all retries'
            )
          }
          throw err
        }
      }

      throw lastError
    }
  }

  let callCount = 0
  const mockFn = async () => {
    callCount++
    throw new Error('ERR_INVALID_QUERY')
  }

  await t.exception(
    () => wrk._withMongoRetry(mockFn),
    /ERR_INVALID_QUERY/
  )

  t.is(callCount, 1, 'should have called function only once (no retries)')
  t.is(mockLogger.warn.callCount, 0, 'should not log retry warnings for non-transient errors')
})

test('_withMongoRetry handles exponential backoff correctly', async (t) => {
  t.plan(3)

  const mockLogger = {
    warn: sinon.spy(),
    error: sinon.spy()
  }

  const wrk = {
    logger: mockLogger,
    _isMongoTransientError (err) {
      const message = err.message || ''
      return message.includes('Pool was force destroyed')
    },
    async _withMongoRetry (fn, maxRetries = 2) {
      let lastError

      for (let attempt = 0; attempt <= maxRetries; attempt++) {
        try {
          return await fn()
        } catch (err) {
          lastError = err

          if (this._isMongoTransientError(err) && attempt < maxRetries) {
            const backoffMs = 200 * Math.pow(2, attempt)
            this.logger.warn(
              { err: err.message, attempt: attempt + 1, maxRetries, backoffMs },
              'MongoDB query retry due to transient error'
            )
            await new Promise(resolve => setTimeout(resolve, backoffMs))
            continue
          }

          if (attempt === maxRetries && this._isMongoTransientError(err)) {
            this.logger.error(
              { err: err.message, attempts: maxRetries + 1 },
              'MongoDB query failed after all retries'
            )
          }
          throw err
        }
      }

      throw lastError
    }
  }

  const mockFn = async () => {
    throw new Error('Pool was force destroyed')
  }

  const start = Date.now()
  await t.exception(
    () => wrk._withMongoRetry(mockFn),
    /Pool was force destroyed/
  )
  const elapsed = Date.now() - start

  // Should have backoff: 200ms (attempt 1) + 400ms (attempt 2) = 600ms minimum
  t.ok(elapsed >= 600, `should have total backoff of at least 600ms, got ${elapsed}ms`)

  // Verify backoff values in log calls
  const firstCallBackoff = mockLogger.warn.getCall(0).args[0].backoffMs
  const secondCallBackoff = mockLogger.warn.getCall(1).args[0].backoffMs
  t.alike([firstCallBackoff, secondCallBackoff], [200, 400], 'should use exponential backoff: 200ms, 400ms')
})
